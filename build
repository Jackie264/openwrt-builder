#!/bin/bash
set -euo pipefail

START_TIME=$(date +%s)
BUILD_DIR="$HOME/Downloads/openwrt-24.10"
OUTPUT_BASE="$HOME/Downloads/firmware"
CONFIG_DIR="$HOME/Downloads/configs"
BACKUP_DIR="$HOME/Downloads/backup"
LOCAL_FEED_DIR="$HOME/Downloads/package"
FEED_NAME="mypackages"
KERNEL_VERSION="6.6.86-1"
ORIGIN_URL="downloads.openwrt.org/releases"
BRANCH="openwrt-24.10"

MYFEED_URL=""
DEVICE=""
OUTPUT_DIR=""
ARCH_PACKAGES=""
TARGET=""
SUBTARGET=""
GIT_TAG=""
GIT_NOV_TAG=""
IPADDR=""
TARGET_TAG=""
GIT_PULL_COMMIT=""
custom_key_file=""

BACKUP_LIST=(
	./include/kernel-defaults.mk
	./package/base-files/files/bin/config_generate
	./feeds.conf.default
)

select_git_target() {
	if [ -z "$BRANCH" ]; then
		echo "❌ Error: BRANCH variable is not set."
		exit 1
	fi

	echo "🌐 Fetching all remote tags from remote repository..."
	local current_dir=$(pwd)
	cd "$BUILD_DIR" || { echo "❌ Error: Cannot enter $BUILD_DIR!"; exit 1; }

	local all_tags=$(git ls-remote --tags origin 2>/dev/null | sed 's#^.*refs/tags/##' | sed '/\^[{][}]$/d')
	cd "$current_dir"

	local filtered_tags=""
	local tag_list=""
	local tag_count=0

	if [ -z "$all_tags" ]; then
		echo "⚠️ Cannot find any remote tags."
		echo "   Building with a target tag is not possible."
		exit 1
	fi

	echo "Filtering tags to show v24.10+..."
	filtered_tags=$(echo "$all_tags" | grep '^v24\.10')
	
	if [ -z "$filtered_tags" ]; then
		echo "⚠️ Cannot find any v24.10+ tags in the remote repository."
		echo "   Cannot build with none tag."
		exit 1
	fi

	echo "Preparing filtered tag list for selection..."

	tag_count=$(echo "$filtered_tags" | wc -l)

	for tag in $filtered_tags; do
		tag_list+="$tag \"$tag\" "
	done

	local default_tag=$(echo "$filtered_tags" | tail -n 1)

	if [ -z "$default_tag" ]; then
		unset default_tag
	fi

	if [ -n "$default_tag" ]; then
		TARGET_TAG=$(whiptail --title "Select Target Tag (v24.10+)" --menu "Please choose the tag:" 25 60 $tag_count $tag_list --default-item "$default_tag" 3>&1 1>&2 2>&3) || exit 1
	else
		TARGET_TAG=$(whiptail --title "Select Target Tag (v24.10+)" --menu "Please choose the tag:" 25 60 $tag_count $tag_list 3>&1 1>&2 2>&3) || exit 1
	fi

	echo "✅ Selected tag: $TARGET_TAG"
	BUILD_FROM_BRANCH_HEAD=false
}

restore_git_state() {
	if [ -n "$GIT_PULL_COMMIT" ]; then
		echo "↩️ Restoring Git repository to $GIT_PULL_COMMIT..."
		if [ -d "$BUILD_DIR/.git" ]; then
			if [ "$(pwd)" != "$BUILD_DIR" ]; then
				echo "ℹ️ Changing directory to $BUILD_DIR for Git restore..."
				cd "$BUILD_DIR" || { echo "❌ Error: Cannot enter $BUILD_DIR during Git repository restore. "; return 1; }
			fi
			git reset --hard "$GIT_PULL_COMMIT" || { echo "❌ Error: git reset --hard $GIT_PULL_COMMIT failed! "; return 1; }
			echo "🧹 Running make clean to remove build artifacts..."
			make clean || { echo "⚠️ Warning: make clean failed!"; }
			echo "✅ Git repository restored."
		else
			echo "⚠️ Warning: Git repository $BUILD_DIR/.git does not exist, skipping Git repository restore."
			return 1
		fi
	fi
}

exit_handler() {
	local exit_status=$?
	echo "Running cleanup process..."
	restore_git_state
	echo "Cleanup process finished."
	exit "$exit_status"
}

setup_git_repository() {
	echo "🛠️ Setting up Git repository..."
	echo "🔄 Git checkout: $BRANCH"
	git checkout "$BRANCH" || { echo "❌ Error: Failed to checkout $BRANCH."; exit 1; }
	echo "⬇️ Pulling latest commits for branch '$BRANCH'..."
	git pull || { echo "⚠️ Warning: Failed to pull updates. Check network or repository. Using current branch state."; }
	GIT_PULL_COMMIT=$(git rev-parse HEAD)
	echo "ℹ️ Recorded commit after Git pull: $GIT_PULL_COMMIT"
	select_git_target

	if [ "$BUILD_FROM_BRANCH_HEAD" = "true" ]; then
		echo "ℹ️ Building from branch head '$BRANCH'. Skipping tag checkout."
	else
		echo "😴 Please wait one second..."
		sleep 1
		echo "🏷️ Git checkout: $TARGET_TAG"
		git checkout "$TARGET_TAG" || { echo "❌ Error: Failed to checkout $TARGET_TAG."; exit 1; }
		echo "🔄 Updating submodules for tag '$TARGET_TAG'..."
		git submodule update --init --recursive || { echo "❌ Error: Failed to update submodules for tag '$TARGET_TAG'."; exit 1; }
	fi

	echo "🗑️ Restoring files listed in BACKUP_LIST..."
	git restore "${BACKUP_LIST[@]}" || { echo "⚠️ Warning: Failed to git restore files in BACKUP_LIST."; }
	echo "✅ Finished setting up Git repository."
}

restore_original_files() {
	echo "🔁 Restoring original files..."
	for file in "${BACKUP_LIST[@]}"; do
		base_name=$(basename "$file")
		[ -f "$BACKUP_DIR/$base_name" ] && cp "$BACKUP_DIR/$base_name" "$file"
	done
}

backup_original_files() {
	echo "📦 Backing up original files..."
	mkdir -p "$BACKUP_DIR"
	for file in "${BACKUP_LIST[@]}"; do
		base_name=$(basename "$file")
		[ -f "$file" ] && cp "$file" "$BACKUP_DIR/$base_name"
	done
}

set_vermagic_key() {
	VERMAGIC_KEY=$(echo "$DEVICE" | awk -F. '{print $NF}')
}

patch_device_files() {
	echo "🧩 Applying all patch files for $DEVICE..."
	install -m 644 "$CONFIG_DIR/config.$DEVICE" ./.config
	install -m 644 "$CONFIG_DIR/vermagic.$VERMAGIC_KEY" ./vermagic
	install -m 755 "$CONFIG_DIR/config_generate.$DEVICE" ./package/base-files/files/bin/config_generate
	install -m 644 "$CONFIG_DIR/kernel-defaults.mk" ./include/kernel-defaults.mk
}

process_and_copy_key_download_script_template() {
	echo "📝 Processing key download script template and copying to output packages directory..."

	local pub_key_source="$BUILD_DIR/key-build.pub"
	if [ ! -f "$pub_key_source" ]; then
		echo "⚠️ Warning: key-build.pub not found at $pub_key_source. Cannot generate key download script."
		echo "   Please confirm enabled signature in make menuconfig, and succeed with make defconfig."
		echo "   Key download script will not be available in output."
		return 1
	fi

	custom_key_file=$(sha256sum "$pub_key_source" | head -c 16)
	if [ -z "$custom_key_file" ]; then
		 echo "❌ Error: Failed to calculate hash for key-build.pub. Cannot generate key download script."
		 return 1
	fi

	if [ -z "$MYFEED_URL" ] || [ -z "$DEVICE" ] || [ -z "$OUTPUT_DIR" ]; then
		echo "❌ Error: MYFEED_URL, DEVICE, or OUTPUT_DIR variables are not set. Cannot generate key download script."
		return 1
	fi

	local template_source="$CONFIG_DIR/98-download-key.template"
	local output_packages_dir="$OUTPUT_DIR/packages"
	local dest_script_path="$output_packages_dir/98-download-custom-key"

	if [ ! -f "$template_source" ]; then
		echo "❌ Error: Script template file not found: $template_source. Cannot generate key download script."
		return 1
	fi

	echo "ℹ️ Key hash filename: $custom_key_file"
	echo "ℹ️ Processing template: $template_source"
	echo "ℹ️ Generating script to: $dest_script_path"

	mkdir -p "$output_packages_dir"

	sed \
		-e "s|__MYFEED_URL__|$MYFEED_URL|g" \
		-e "s|__DEVICE__|$DEVICE|g" \
		-e "s|__CUSTOM_KEY_FILE__|$custom_key_file|g" \
		"$template_source" > "$dest_script_path"

	if [ $? -ne 0 ]; then
		echo "❌ Error: Failed to process script template with sed."
		[ -f "$dest_script_path" ] && rm "$dest_script_path"
		return 1
	fi

	chmod +x "$dest_script_path"
	echo "✅ Processed template and copied script to: $dest_script_path"
	echo "📢 Remember to upload key-build.pub to your Feed Web server!"
	local key_upload_url="https://$MYFEED_URL/$DEVICE/latest/myfeeds-cert/$custom_key_file"
	echo "   请将源码目录下的 '$pub_key_source' 文件手动上传到以下 URL 对应的 Web 路径下："
	echo "   $key_upload_url"

	return 0
}

copy_public_key() {
	echo "📤 Copying public key (key-build.pub) to firmware output directory for upload..."
	local pub_key_source="$BUILD_DIR/key-build.pub"
	if [ -z "$OUTPUT_DIR" ] || [ -z "$custom_key_file" ]; then
		echo "❌ Error: OUTPUT_DIR or custom_key_file is not set. Cannot copy public key."
		return 1
	fi

	local dest_dir="$OUTPUT_DIR/myfeeds-cert"
	local dest_filename="$custom_key_file"

	if [ -f "$pub_key_source" ]; then
		mkdir -p "$dest_dir"
		cp "$pub_key_source" "$dest_dir/$dest_filename"
		echo "✅ Public key copied to $dest_dir/$dest_filename"
	else
		echo "⚠️ Warning: Public key file $pub_key_source not found."
		return 1
	fi

	return 0
}

copy_firstboot_script() {
	echo "📝 Installing firstboot script..."
	local script_source="$CONFIG_DIR/firstboot-config.sh"
	local script_dest_dir="package/base-files/files/etc/uci-defaults"
	local script_dest_file="$script_dest_dir/99-firstboot-config"
	if [ -f "$script_source" ]; then
		mkdir -p "$script_dest_dir"
		install -m 755 "$script_source" "$script_dest_file"
		echo "✅ Installed firstboot script to: $script_dest_file, setting permission 755"
	else
		echo "⚠️ Warning: Firstboot script file does not exist: $script_source"
		echo "   Please create firstboot-config.sh under $CONFIG_DIR next time."
		echo "   Building will continue, but no feeds cleanup will be performed on first boot."
	fi
	sleep 2
}

update_local_feeds() {
	echo "🔄 Updating local packages in $LOCAL_FEED_DIR..."
	for dir in "$LOCAL_FEED_DIR"/*; do
		if [ -d "$dir/.git" ]; then
			echo "➡️  Pulling updates in $(basename "$dir") ..."
			git -C "$dir" pull --ff-only || echo "⚠️  Failed to update $(basename "$dir")"
		fi
	done
}

setup_local_feed() {
	echo "📦 Setting up local feed..."
	if ! grep -q "src-link $FEED_NAME" feeds.conf.default; then
		echo "src-link $FEED_NAME $LOCAL_FEED_DIR" >> feeds.conf.default
		echo "✅ Added feed: $FEED_NAME"
	else
		echo "ℹ️ Local feed $FEED_NAME already exists in feeds.conf.default"
	fi
	./scripts/feeds update -a
	./scripts/feeds install -a
}

select_device() {
	local base_device
	base_device=$(whiptail --title "Select Device" --menu "Choose a device to build:" 15 50 3 \
		"mx5300" "Linksys MX5300 (IPQ807x)" \
		"whw03v2" "Linksys WHW03 v2 (IPQ40xx)" \
		3>&1 1>&2 2>&3) || exit 1
	case "$base_device" in
		mx5300)
			DEVICE="mx5300"
			MYFEED_URL="feeds.onenas.fun"
			;;
		whw03v2)
			local sub_scene
			sub_scene=$(whiptail --title "WHW03V2 Configuration" --menu "Select deployment profile:" 12 50 2 \
				"home" "Home Enviroment" \
				"office" "Office Enviroment" \
				3>&1 1>&2 2>&3) || exit 1

			sub_scene=$(printf "%s" "$sub_scene" | sed 's/\xc2\xa0$//')

			DEVICE="$sub_scene.whw03v2"
			if [ "$sub_scene" = "home" ]; then
				MYFEED_URL="feeds.onenas.fun"
			else
				MYFEED_URL="feeds.sh-mtgc.com"
			fi
			;;
		*)
			echo "❌ Invalid selection"
			exit 1
			;;
	esac
}

clean_source_tree() {
	echo "🧹 Cleaning up old build artifacts..."
	if [ -f "$BUILD_DIR/Makefile" ]; then
		cd "$BUILD_DIR" || exit 1
		make clean
	else
		echo "❌ Makefile not found in $BUILD_DIR, cannot clean!"
		exit 1
	fi
}

make_output_folder() {
	echo "📁 Making output folder..."
	DATE_TAG=$(date +"%Y%m%d_%H%M")
	OUTPUT_DIR="$OUTPUT_BASE/$DEVICE/$DATE_TAG"
	mkdir -p "$OUTPUT_DIR"
	LINK_PATH="$OUTPUT_BASE/$DEVICE/latest"
	ln -sfn "$DATE_TAG" "$LINK_PATH"
	if [ -L "$LINK_PATH" ]; then
		echo "🔗 'latest' symlink created → $LINK_PATH → $DATE_TAG"
	else
		echo "❌ Failed to create 'latest' symlink at $LINK_PATH"
	fi
}

prepare_config() {
	echo "📦 Setting ROOTFS output dir..."
	sed -i "/^CONFIG_TARGET_ROOTFS_DIR=.*/d" .config
	echo "CONFIG_TARGET_ROOTFS_DIR=\"$OUTPUT_DIR\"" >> .config
}

make_deconfig() {
	echo "⚙️ Running make defconfig..."
	make defconfig || {
		echo "❌ make defconfig failed!"
		exit 1
	}
}

detect_target_info() {
	echo "🔍 Detecting target info..."
	local config_file=".config"
	TARGET=$(grep -oP '^CONFIG_TARGET_BOARD="\K[^"]+' "$config_file")
	SUBTARGET=$(grep -oP '^CONFIG_TARGET_SUBTARGET="\K[^"]+' "$config_file")
	ARCH_PACKAGES=$(grep -oP '^CONFIG_TARGET_ARCH_PACKAGES="\K[^"]+' "$config_file")
	GIT_TAG=$(git describe --tags --always 2>/dev/null || echo "unknown")
	GIT_NOV_TAG=${GIT_TAG#v}
	IPADDR=$(grep -oP 'lan\)\s+ipad=\$\{ipaddr:-"\K[^"]+' package/base-files/files/bin/config_generate | head -n1)
	if [[ -z "$TARGET" || -z "$SUBTARGET" || -z "$ARCH_PACKAGES" ]]; then
		echo "❌ Failed to detect TARGET, SUBTARGET, or ARCH_PACKAGES"
		exit 1
	fi
	echo "📦 GIT TAG=$GIT_TAG TARGET=$TARGET | SUBTARGET=$SUBTARGET | ARCH=$ARCH_PACKAGES | IP=$IPADDR"
}

generate_customfeeds_conf() {
	echo "📝 Generating customfeeds.conf for $DEVICE..."
	local ABI_HASH=$(cat ./vermagic)
	if [ -z "$ABI_HASH" ]; then
		echo "❌ Error: Cannot get ABI-hash from ./vermagic!"
		echo "   This file is expected to exist after patch_device_files. Make sure ./vermagic exists and is not empty."
		exit 1
	fi
	local KMODS_URL="https://$ORIGIN_URL/$GIT_NOV_TAG/targets/$TARGET/$SUBTARGET/kmods/$KERNEL_VERSION-$ABI_HASH"
	cat > package/system/opkg/files/customfeeds.conf <<EOF
src/gz my_kmod https://$MYFEED_URL/$DEVICE/latest/targets/packages
src/gz my_packages https://$MYFEED_URL/$DEVICE/latest/packages/mypackages
src/gz openwrt_kmods $KMODS_URL

EOF
	echo "✅ Created customfeeds.conf,"
	echo "   kmods source is: $KMODS_URL"
	sleep 5
}

target_summary() {
	echo ""
	echo "✅ To build firmware for: $DEVICE"
	echo "📁 Firmware will save to: $OUTPUT_DIR"
	echo "📦 Target:                $TARGET"
	echo "📦 Subtarget:             $SUBTARGET"
	echo "📦 Packages arch:         $ARCH_PACKAGES"
	echo "🌐 Default IP:            $IPADDR"
	echo "🔖 Git Tag:               $GIT_TAG"
	echo ""
	sleep 2
}

build_firmware() {
	echo "⚙️ Starting build for $DEVICE..."
	make download -j$(nproc)
	if ! make V=s -j$(nproc); then
		echo "⚠️ Multithread build failed. Retrying with single thread..."
		make V=s -j1
	fi
}

copy_all_output() {
	echo "📤 Copying firmware and packages..."
	rsync -a bin/targets/"$TARGET"/"$SUBTARGET"/ "$OUTPUT_DIR/targets/"
	rsync -a bin/packages/"$ARCH_PACKAGES"/ "$OUTPUT_DIR/packages/"
}

final_summary() {
	echo ""
	echo "✅ Build completed for $DEVICE"
	echo "📁 Firmware saved to:  $OUTPUT_DIR"
	echo "📦 Target:             $TARGET"
	echo "📦 Subtarget:          $SUBTARGET"
	echo "📦 Packages arch:      $ARCH_PACKAGES"
	echo "🌐 Default IP:         $IPADDR"
	echo "🌐 Feed Source:        $MYFEED_URL"
	echo "🔖 Git Tag:            $GIT_TAG"
	echo ""
	local END_TIME=$(date +%s)
	local DURATION=$((END_TIME - START_TIME))
	local HOURS=$((DURATION / 3600))
	local MINUTES=$(( (DURATION % 3600) / 60 ))
	local SECONDS=$((DURATION % 60))
	local DURATION_STRING=""
	if [ "$HOURS" -gt 0 ]; then
		DURATION_STRING+="${HOURS}h "
	fi
	if [ "$MINUTES" -gt 0 ] || [ "$HOURS" -gt 0 ]; then
		DURATION_STRING+="${MINUTES}m "
	fi
	if [ "$HOURS" -gt 0 ] || [ "$MINUTES" -gt 0 ] || [ "$SECONDS" -gt 0 ]; then
		DURATION_STRING+="${SECONDS}s"
	fi
	DURATION_STRING=$(echo "$DURATION_STRING" | sed 's/ $//')
	if [ -z "$DURATION_STRING" ]; then
		DURATION_STRING="0s"
	fi
	local FINISH_TIME_CST=$(TZ='Asia/Shanghai' date --date="@$END_TIME" +'%Y-%m-%d %H:%M:%S %Z')
	echo "⏰ Build finished at:  $FINISH_TIME_CST"
	echo "⏱️ Total duration:     $DURATION_STRING"
	echo ""
}

main() {
	cd "$BUILD_DIR" || exit 1
	trap 'exit_handler' EXIT
	setup_git_repository
	select_device
	set_vermagic_key
	clean_source_tree
	update_local_feeds
	patch_device_files
	copy_firstboot_script
	setup_local_feed
	make_output_folder
	prepare_config
	make_deconfig
	process_and_copy_key_download_script_template
	copy_public_key
	detect_target_info
	generate_customfeeds_conf
	target_summary
	build_firmware
	final_summary
	copy_all_output
}

main "$@"
